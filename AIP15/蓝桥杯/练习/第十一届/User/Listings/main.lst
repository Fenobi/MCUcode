C51 COMPILER V9.60.0.0   MAIN                                                              04/04/2023 20:01:15 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(9,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 
   2                          å¤§æ¨¡æ¿ V3 æ›´æ–°è¯´æ˜ è‹¥éç‰¹æ®Šéœ€æ±‚ æ— éœ€ä½¿ç”¨æ­¤ç‰ˆæœ¬ ï¼ˆå› ä¸ºæˆ‘è§‰å¾—è¿™æ ·è°ƒç”¨èµ·æ¥è
             -¿˜æ˜¯ç¨å¾®æœ‰ç‚¹å„¿éº»çƒ¦çš„ï¼‰
   3                          
   4                          ä¼˜åŒ–è®¾è®¡ä¸²å£ç¨‹åºæ—¶ å†…å­˜å®¹æ˜“æº¢å‡ºçš„é—®é¢˜
   5                          
   6                          ä¾‹ç¨‹è°ƒç”¨å¦‚ä¸‹ï¼š
   7                          
   8                          -------------Ledç›¸å…³-------------
   9                          Led X å¼€ -> Function_Buf[X] |= 1
  10                          Led X å…³ -> Function_Buf[X] &= 0
  11                          Led X å¼€å…³åˆ‡æ¢ -> Function_Buf[X] ^= 1
  12                          
  13                          -------------Segç›¸å…³-------------
  14                          Point X å¼€ -> Function_Buf[X] |= 1  << 4
  15                          Point X å…³ -> Function_Buf[X] &= 0  << 4
  16                          Point X å¼€å…³åˆ‡æ¢ -> Function_Buf[X] ^= 1  << 4
  17                          
  18          */
  19          
  20          /* å®å®šä¹‰å£°æ˜åŒºåŸŸ */
  21          #define Key_Slow 10 //æŒ‰é”®å‡é€Ÿæ—¶é—´
  22          #define Seg_Slow 500 //æ•°ç ç®¡å‡é€Ÿæ—¶é—´
  23          #define Uart_Slow 200 //ä¸²å£å‡é€Ÿæ—¶é—´
  24          #define Uart_Max_Commad 10 //ä¸²å£æŒ‡ä»¤é•¿åº¦ä¸Šé™
  25          
  26          /* å¤´æ–‡ä»¶å£°æ˜åŒºåŸŸ */
  27          #include <Init.h> //åˆå§‹åŒ–ä¸“ç”¨å¤´æ–‡ä»¶
  28          #include <Key.h> //æŒ‰é”®ä¸“ç”¨å¤´æ–‡ä»¶
  29          #include <Seg.h> //æ•°ç ç®¡ä¸“ç”¨å¤´æ–‡ä»¶
  30          #include <Led.h> //Ledä¸“ç”¨å¤´æ–‡ä»¶
  31          #include <Uart.h> //ä¸²å£ä¸“ç”¨å¤´æ–‡ä»¶
  32          #include <pcf8591.h>
  33          #include <ds18b20.h>
  34          
  35          /* å˜é‡å£°æ˜åŒºåŸŸ */
  36          unsigned int Proc_Slow_Down;//å‡½æ•°å‡é€Ÿä¸“ç”¨å˜é‡
  37          unsigned char Key_Val,Key_Old;//æŒ‰é”®æ‰«æä¸“ç”¨å˜é‡
  38          unsigned char Scan_Pos;//åŠ¨æ€æ‰«æä¸“ç”¨å˜é‡
  39          unsigned char Seg_Buf[8] = {10,10,10,10,10,10,10,10};//æ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„ é»˜è®¤ç†„ç­
  40          unsigned char Function_Buf[8] = {0,0,0,0,0,0,0,0};//åŠŸèƒ½æ•°æ®å­˜æ”¾æ•°ç»„ é«˜ä½-LedçŠ¶æ€ ä½ä½-å°æ•
             -°ç‚¹çŠ¶æ€
  41          unsigned char Uart_Recv[10];//ä¸²å£æ¥æ”¶æ•°æ®å‚¨å­˜æ•°ç»„ é»˜è®¤10ä¸ªå­—èŠ‚ è‹¥æ¥æ”¶æ•°æ®è¾ƒé•¿ å¯æ›
             -´æ”¹æœ€å¤§å­—èŠ‚æ•°
  42          unsigned char Uart_Recv_Index;//ä¸²å£æ¥æ”¶æ•°ç»„æŒ‡é’ˆ
  43          unsigned char Uart_Send[10];//ä¸²å£æ¥æ”¶æ•°æ®å‚¨å­˜æ•°ç»„ é»˜è®¤10ä¸ªå­—èŠ‚ è‹¥å‘é€æ•°æ®è¾ƒé•¿ å¯æ›
             -´æ”¹æœ€å¤§å­—èŠ‚æ•°
  44          u8 Temperature;
  45          u8 Temperature_A[] = {0, 0};
  46          u8 Temperature_B[] = {30,20};
  47          u8 mode = 1;
  48          u8 mode_min=1;
  49          u8 Temperature_Params_Index;
  50          u8 error_flag;
C51 COMPILER V9.60.0.0   MAIN                                                              04/04/2023 20:01:15 PAGE 2   

  51          
  52          /* æŒ‰é”®å¤„ç†å‡½æ•° */
  53          void Key_Proc()
  54          {
  55   1              unsigned char Key_Up,Key_Down;//å®šä¹‰å±€éƒ¨å˜é‡å‡å°å†…å­˜å ç”¨
  56   1              if(Proc_Slow_Down % Key_Slow) return;//æŒ‰é”®å‡é€Ÿç¨‹åº
  57   1      
  58   1              Key_Val = Key_BTN_Read(); // è¯»å–æŒ‰é”®é”®ç å€¼
  59   1              Key_Down = Key_Val & (Key_Val ^ Key_Old);//æ•æ‰æŒ‰é”®ä¸‹é™æ²¿
  60   1              Key_Up = ~Key_Val & (Key_Val ^ Key_Old);//æ•æ‰æŒ‰é”®ä¸Šé™æ²¿
  61   1              Key_Old = Key_Val;//è¾…åŠ©æ‰«æå˜é‡
  62   1              switch(Key_Down)
  63   1              {
  64   2                      case 4:
  65   2                              mode ^= 1;
  66   2                              if (mode==0)
  67   2                              {
  68   3                                      Temperature_A[0] = Temperature_B[0];
  69   3                                      Temperature_A[1] = Temperature_B[1];
  70   3                                      Temperature_Params_Index = 0;
  71   3                              }
  72   2                              else
  73   2                              {
  74   3                                      if(Temperature_A[0]>Temperature_A[1])
  75   3                                      {
  76   4                                              Temperature_B[0] = Temperature_A[0];
  77   4                                              Temperature_B[1] = Temperature_A[1];
  78   4                                              error_flag = 0;
  79   4                                      }
  80   3                                      else
  81   3                                      {
  82   4                                              error_flag = 1;
  83   4                                      }
  84   3                                      
  85   3                              }       
  86   2                              break;
  87   2                      case 5:
  88   2                              mode_min ^= 1;
  89   2                              Temperature_Params_Index ^= 1;
  90   2                              break;
  91   2                      case 6:
  92   2                              ++Temperature_A[Temperature_Params_Index];
  93   2                              if (Temperature_A[Temperature_Params_Index] > 100)
  94   2                                      Temperature_A[Temperature_Params_Index] = 99;
  95   2                              break;
  96   2                      case 7:
  97   2                              --Temperature_A[Temperature_Params_Index];
  98   2                              if (Temperature_A[Temperature_Params_Index] == 255 )
  99   2                                      Temperature_A[Temperature_Params_Index] = 0;
 100   2              }
 101   1                      
 102   1      }
 103          
 104          /* ä¿¡æ¯å¤„ç†å‡½æ•° */
 105          void Seg_Proc()
 106          {
 107   1              if (Proc_Slow_Down % Seg_Slow)
 108   1                      return; // ä¿¡æ¯å‡é€Ÿç¨‹åº
 109   1              Temperature = ds18b20_read_temperture();
 110   1      
 111   1              if(mode)
 112   1              {
C51 COMPILER V9.60.0.0   MAIN                                                              04/04/2023 20:01:15 PAGE 3   

 113   2                      Seg_Buf[0] = 11; // æ ‡è¯†ç¬¦C
 114   2                      Seg_Buf[3] = 10;
 115   2                      Seg_Buf[4] = 10;
 116   2                      Seg_Buf[6] = (unsigned char)Temperature / 10 % 10;
 117   2                      Seg_Buf[7] = (unsigned char)Temperature % 10;
 118   2              }
 119   1              else
 120   1              {
 121   2                      Seg_Buf[0] = 12; // æ ‡è¯†ç¬¦C
 122   2                      Seg_Buf[3] = Temperature_A[0] / 10 % 10;
 123   2                      Seg_Buf[4] = Temperature_A[0] % 10;
 124   2                      Seg_Buf[6] = Temperature_A[1] / 10 % 10;
 125   2                      Seg_Buf[7] = Temperature_A[1] % 10;
 126   2              }
 127   1              
 128   1      }
 129          
 130          /* å…¶ä»–å¤„ç†å‡½æ•° */
 131          void Led_Proc()
 132          {
 133   1              u8 i;
 134   1              Function_Buf[0] = (Temperature > Temperature_A[0]);
 135   1              Function_Buf[1] = (Temperature <= Temperature_A[0] && Temperature >= Temperature_A[1]);
 136   1              Function_Buf[2] = (Temperature < Temperature_A[1]);
 137   1              Function_Buf[3] = error_flag;
 138   1              for (i = 0; i < 3; i++)
 139   1              {
 140   2                      if (Function_Buf[i] == 1)
 141   2                      {
 142   3                              AD_write(51 * (4 - i));
 143   3                              break;
 144   3                      }
 145   2              }
 146   1      }
 147          
 148          /* ä¸²å£å¤„ç†å‡½æ•° */
 149          void Uart_Proc()
 150          {
 151   1              if(Proc_Slow_Down % Uart_Slow) return;//ä¸²å£å‡é€Ÿç¨‹åº      
 152   1              
 153   1      }
 154          
 155          /* å®šæ—¶å™¨0åˆå§‹åŒ–å‡½æ•° */
 156          void Timer0Init(void)           //1æ¯«ç§’@12.000MHz
 157          {
 158   1              AUXR &= 0x7F;           //å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 159   1              TMOD &= 0xF0;           //è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 160   1              TL0 = 0x18;             //è®¾ç½®å®šæ—¶åˆå€¼
 161   1              TH0 = 0xFC;             //è®¾ç½®å®šæ—¶åˆå€¼
 162   1              TF0 = 0;                //æ¸…é™¤TF0æ ‡å¿—
 163   1              TR0 = 1;                //å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 164   1              ET0 = 1;                //å®šæ—¶å™¨0ä¸­æ–­æ‰“å¼€
 165   1              EA = 1;                 //æ€»ä¸­æ–­æ‰“å¼€
 166   1      }
 167          
 168          /* å®šæ—¶å™¨0ä¸­æ–­æœåŠ¡å‡½æ•° */
 169          void Timer0Server() interrupt 1
 170          {
 171   1              if(++Proc_Slow_Down == 500) Proc_Slow_Down = 0;//å‡é€Ÿä¸“ç”¨
 172   1              if(++Scan_Pos == 8) Scan_Pos = 0;//æ‰«æä¸“ç”¨
 173   1              Seg_Disp(Scan_Pos,Seg_Buf[Scan_Pos],Function_Buf[Scan_Pos] & 0xF0);//æ•°ç ç®¡æ˜¾ç¤º
 174   1              Led_Disp(Scan_Pos,Function_Buf[Scan_Pos] & 0x0F);//Ledæ˜¾ç¤º
C51 COMPILER V9.60.0.0   MAIN                                                              04/04/2023 20:01:15 PAGE 4   

 175   1      }
 176          
 177          /* ä¸²å£1ä¸­æ–­æœåŠ¡å‡½æ•° */
 178          void Uart1Server() interrupt 4
 179          {
 180   1              if(RI == 1 && Uart_Recv_Index < Uart_Max_Commad) //ä¸²å£æ¥æ”¶æ•°æ®
 181   1              {
 182   2                      Uart_Recv[Uart_Recv_Index] = SBUF;
 183   2                      Uart_Recv_Index++;
 184   2                      RI = 0;
 185   2              }
 186   1      }
 187          
 188          void main()
 189          {
 190   1              ds18b20_read_temperture();
 191   1              Delay_ms(750);
 192   1              Sys_Init();//ä¸Šç”µç³»ç»Ÿåˆå§‹åŒ–
 193   1              //UartInit();   //ä¸²å£åˆå§‹åŒ–
 194   1              Timer0Init();//å®šæ—¶å™¨0åˆå§‹åŒ–
 195   1              while(1)
 196   1              {
 197   2                      Key_Proc();
 198   2                      Seg_Proc();
 199   2                      Led_Proc();
 200   2                      Uart_Proc();
 201   2              }
 202   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    566    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     51       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
