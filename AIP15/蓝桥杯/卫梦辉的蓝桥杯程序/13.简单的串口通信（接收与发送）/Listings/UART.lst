C51 COMPILER V9.59.0.0   UART                                                              12/19/2022 15:51:54 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\Objects\UART.obj
COMPILER INVOKED BY: D:\MDK5\C51\BIN\C51.EXE UART.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\UART.ls
                    -t) TABS(2) OBJECT(.\Objects\UART.obj)

line level    source

   1          #include "uart.h"
   2          #include <string.h>           // 加入此头文件后,可使用strstr库函数
   3          #include "LCM12864.h"
*** WARNING C318 IN LINE 3 OF UART.c: can't open file 'LCM12864.h'
   4          #include "Delay.h"
   5          
   6          #define Buf_Max 50//字符最大长度
   7          
   8          volatile uint8 Flag=FALSE;
*** ERROR C202 IN LINE 8 OF UART.c: 'FALSE': undefined identifier
   9          uint8 xdata Rec_Buf1[Buf_Max];     //接收串口1缓存数组
  10          uint8 xdata Rec_Buf2[Buf_Max];     //接收串口2缓存数组
  11          uint8 ii = 0;       
  12          uint8 jj = 0;
  13          
  14          uint8 uart1temp;
  15          
  16          /*******************************************************************************************串口1
  17           * 描  述 : 串口1初始化函数
  18           * 入  参 : 无
  19           * 返回值 : 无
  20          备注：波特率9600bps   晶振11.0592MHz
  21           **************************************************************************/
  22          void Uart1_Init(void)//串口1初始化函数
  23          { 
  24   1        PCON &= 0x3f;   //波特率不倍速，串行口工作方式由SM0、SM1决定
  25   1        SCON = 0x50;    //8位数据,可变波特率，启动串行接收器
  26   1        AUXR |= 0x40;   //定时器1时钟为Fosc,即1T
  27   1        AUXR &= 0xfe;   //串口1选择定时器1为波特率发生器
  28   1        TMOD &= 0x0f;   //清除定时器1模式位
  29   1        TMOD |= 0x20;   //设定定时器1为8位自动重装方式
  30   1          
  31   1          //设置串口管角默认为P30, P31
  32   1      //    AUXR1 &= 0x3F;                         //设置串口引脚，选择RX:P3.0  TX:P3.1
  33   1        
  34   1          P3M0 &= 0xBF;P3M1 &= 0xBF;//设RX:P3.6 为准双向口
  35   1          P3M0 &= 0x7F;P3M1 &= 0x7F;//设TX:P3.7 为准双向口
  36   1          AUXR1 &= 0x7F; AUXR1 |= 0x40;       //设置串口引脚，选择RX:P3.6  TX:P3.7
  37   1        
  38   1        
  39   1      //    AUXR1 &= 0xBF; AUXR1 |= 0x80;       //设置串口引脚，选择RX:P1.6  TX:P7.7(需要使用内部时钟)
  40   1      
  41   1          
  42   1          //选择发送波特率，公式：TL1 = TH1 =256-(晶振)11059200/32/波特率
  43   1          
  44   1        TL1 = 0xDC;       //设定定时初值,波特率9600bps
  45   1        TH1 = 0xDC;       //设定定时器重装值,波特率9600bps
  46   1          
  47   1      //  TL1 = 0xE8;       //设定定时初值,波特率14400bps
  48   1      //  TH1 = 0xE8;       //设定定时器重装值,波特率14400bps
  49   1          
  50   1      //    TL1 = 0xEE;       //设定定时初值,波特率19200bps
  51   1      //  TH1 = 0xEE;       //设定定时器重装值,波特率19200bps
  52   1          
C51 COMPILER V9.59.0.0   UART                                                              12/19/2022 15:51:54 PAGE 2   

  53   1      //    TL1 = 0xF7;       //设定定时初值,波特率38400bps
  54   1      //  TH1 = 0xF7;       //设定定时器重装值,波特率38400bps
  55   1          
  56   1        ET1 = 0;        //禁止定时器1中断
  57   1        TR1 = 1;        //启动定时器1
  58   1        ES = 1;             // 串口1中断打开
  59   1      }
  60          
  61          /**************************************
  62          功能描述：清除串口1缓存内容函数
  63          入口参数：无
  64          返回值：无
  65          ***************************************/
  66          void CLR_Buf1(void)//清除串口1缓存内容函数
  67          {
  68   1        uint8 k;
  69   1          for(k=0;k<Buf_Max;k++)      //将串口1缓存数组的值都清为零
  70   1          {
  71   2              Rec_Buf1[k] = 0;
  72   2          }
  73   1          ii = 0;                    
  74   1      }
  75          /***************************************************************************
  76           * 描  述 : 串口1发送数据函数
  77           * 入  参 : uint8 数据
  78           * 返回值 : 无
  79          *  例如 : SendDataByUart1(0x42);//放送B字母
  80           **************************************************************************/
  81          void SendDataByUart1(uint8 dat)//串口1发送数据函数
  82          {
  83   1          SBUF = dat;                 //写数据到UART数据寄存器
  84   1        while(TI == 0);             //在停止位没有发送时，TI为0即一直等待
  85   1        TI = 0;                     //清除TI位（该位必须软件清零）
  86   1      }
  87          /***************************************************************************
  88           * 描  述 : 串口1发送字符串函数
  89           * 入  参 : 字符串
  90           * 返回值 : 无
  91           **************************************************************************/
  92          void SendStringByUart1(uint8 *s)//串口1发送字符串函数
  93          {
  94   1          ES = 0;                                     // 串口1中断关闭
  95   1      //    CLR_Buf1();                                 //将串口1缓存数组的值都清为零 
  96   1        while(*s)
  97   1        {
  98   2          SendDataByUart1(*s++);       //将字符串中的字符一个一个发送
  99   2        }
 100   1          ES = 1;                                     // 串口1中断打开  
 101   1      }
 102          
 103          /***************************************************************************
 104           * 描  述 : 重定向c库函数printf到USART1
 105           * 入  参 : char dat
 106           * 返回值 : char 
 107           **************************************************************************/
 108          char putchar(char dat)
 109          {
 110   1          SendDataByUart1(dat);           
 111   1          return dat;                    
 112   1      }
 113          /**************************************
 114          功能描述：握手成功与否函数
C51 COMPILER V9.59.0.0   UART                                                              12/19/2022 15:51:54 PAGE 3   

 115          入口参数：uint8 *a
 116          返回值：位
 117          ***************************************/
 118          bit Hand1(uint8 *a)//串口2握手成功与否函数
 119          { 
 120   1          if(strstr(Rec_Buf1,a)!=NULL)     //判断字符串a是否是字符串Rec_Buf1的子串
 121   1            return 1;                      //如果字符串a是字符串Rec_Buf1的子串
 122   1          else
 123   1            return 0;                      //如果字符串a不是字符串Rec_Buf1的子串
 124   1      }
 125          /***************************************************************************
 126           * 描  述 : 串口1中断服务函数
 127           * 入  参 : 无
 128           * 返回值 : 无
 129           **************************************************************************/
 130          void Uart1() interrupt UART1_VECTOR using 1
*** ERROR C141 IN LINE 130 OF UART.c: syntax error near 'UART1_VECTOR', expected 'const'
*** ERROR C132 IN LINE 130 OF UART.c: 'UART1_VECTOR': not in formal parameter list
*** ERROR C141 IN LINE 130 OF UART.c: syntax error near 'using', expected ';'
 131          {
 132              ES = 0;                       // 串口1中断关闭
*** ERROR C244 IN LINE 132 OF UART.c: 'ES': can't initialize, bad type or class
*** ERROR C132 IN LINE 132 OF UART.c: 'ES': not in formal parameter list
 133            if (RI)                       //串行接收到停止位的中间时刻时，该位置1
*** ERROR C141 IN LINE 133 OF UART.c: syntax error near 'if', expected 'hdata'
 134              {
*** ERROR C129 IN LINE 134 OF UART.c: missing ';' before '{'
 135                  RI = 0;                   //清除RI位 （该位必须软件清零）
 136                  Rec_Buf1[ii] = SBUF;       //把串口1缓存SBUF寄存器数据依次存放到数组Rec_Buf1中
 137                  ii++;                      
 138                if(ii>Buf_Max)             //接收数大于定义接收数组最大个数时，覆盖接收数组之前值
 139                  {
 140                      ii = 0;                 
 141                  }           
 142              }
 143              if (TI)                    //在停止位开始发送时，该位置1
 144              {
 145                  TI = 0;                 //清除TI位（该位必须软件清零）
 146              }
 147              ES =  1;                   // 串口1中断打开
 148              
 149          }
 150          
 151          /**************************************************************************************
 152           * 描  述 : 串口1接收到数据后发送出去
 153           * 入  参 : 无
 154           * 返回值 : 无
 155           **************************************************************************************/
 156          void UART1_Tx_Puts(void)
 157          {
 158              if(Flag)                //有新数据通过串口被接收到
 159            { 
 160              ES = 0;                           //串口1中断关闭                   
 161                  SendDataByUart1(uart1temp);       //发送字符 
 162                  SendDataByUart1(0x0D);            //发送换行符
 163                  SendDataByUart1(0x0A);            //发送换行符            
 164              ES = 1;                           //串口1中断打开     
 165              Flag=FALSE;                       //清除接收标识符
 166              }
 167          }
 168          
 169          /*********************************END FILE********************************************/ 
C51 COMPILER V9.59.0.0   UART                                                              12/19/2022 15:51:54 PAGE 4   

 170          uint8 uart2temp;
 171          
 172          /*******************************************************************************************串口2
 173           * 描  述 : 串口2初始化函数
 174           * 入  参 : 无
 175           * 返回值 : 无
 176          备注：波特率9600bps   晶振11.0592MHz
 177           **************************************************************************/
 178          void Uart2_Init(void)
 179          {     
 180            S2CON = 0x50;   //8位数据,可变波特率，启动串行接收器  
 181            AUXR |= 0x04;   //定时器2时钟为Fosc,即
 182              
 183              //设置串口管角
 184          //    P_SW2 &= 0xFE;                         //设置串口引脚，选择RX:P1.0  TX:P1.1
 185              P_SW2 |= 0x01;                         //设置串口引脚，选择RX:P4.6  TX:P4.7
 186              
 187              
 188              //选择发送波特率，公式：[TL1，TH1] =65536-(晶振)11059200/(4*波特率)
 189            T2L = 0xE0;     //设定定时初值,波特率9600bps
 190            T2H = 0xFE;     //设定定时初值,波特率9600bps
 191              
 192          //    T2L = 0x40;     //设定定时初值,波特率14400bps
 193          //  T2H = 0xFF;     //设定定时初值,波14400bps
 194              
 195            AUXR |= 0x10;   //启动定时器2
 196            IE2 |= 0x01;    //串口2中断打开
 197          }
 198          
 199          /**************************************
 200          功能描述：清除串口2缓存内容函数
 201          入口参数：无
 202          返回值：无
 203          ***************************************/
 204          void CLR_Buf2(void)//清除串口2缓存内容函数
 205          {
 206            unsigned char k;
 207              for(k=0;k<Buf_Max;k++)      //将串口2缓存数组的值都清为零
 208            {
 209              Rec_Buf2[k] = 0;
 210              }
 211              jj = 0;                    
 212          }
 213          /***************************************************************************
 214           * 描  述 : 串口2发送数据函数
 215           * 入  参 : uint8 数据
 216           * 返回值 : 无
 217           **************************************************************************/
 218          void SendDataByUart2(uint8 dat)
 219          {
 220              S2BUF = dat;                 //写数据到UART数据寄存器
 221              while(!(S2CON&S2TI));        //在停止位没有发送时，S2TI为0即一直等待
 222              S2CON&=~S2TI;                //清除S2CON寄存器对应S2TI位（该位必须软件清零）
 223          }
 224          /***************************************************************************
 225           * 描  述 : 串口2发送字符串函数
 226           * 入  参 : 字符串
 227           * 返回值 : 无
 228           **************************************************************************/
 229          void SendStringByUart2(uint8 *s)//串口2发送字符串函数
 230          {
 231              IE2 &= 0xFE;                // 串口2中断关闭
C51 COMPILER V9.59.0.0   UART                                                              12/19/2022 15:51:54 PAGE 5   

 232              CLR_Buf2();
 233            while (*s)                  //检测字符串结束标志
 234              {
 235                  SendDataByUart2(*s++);         //发送当前字符
 236              }
 237              IE2 |= 0x01;                     // 串口2中断打开
 238          }
 239          /**************************************
 240          功能描述：握手成功与否函数
 241          入口参数：uint8 *a
 242          返回值：位
 243          ***************************************/
 244          bit Hand2(uint8 *a)//串口2握手成功与否函数
 245          { 
 246            if(strstr(Rec_Buf2,a)!=NULL)      //判断字符串a是否是字符串Rec_Buf2的子串
 247               return 1;                      //如果字符串a是字符串Rec_Buf2的子串
 248            else
 249               return 0;                      //如果字符串a不是字符串Rec_Buf2的子串
 250          }
 251          /***************************************************************************
 252           * 描  述 : 串口2中断服务函数
 253           * 入  参 : 无
 254           * 返回值 : 无
 255           **************************************************************************/
 256          void Uart2() interrupt UART2_VECTOR using 1
 257          {
 258            IE2 &= 0xFE;                               // 串口2中断关闭
 259            if (S2CON & S2RI)                          //串行接收到停止位的中间时刻时，该位置1
 260              {
 261                  S2CON &= ~S2RI;                        //清除S2CON寄存器对应S2RI位（该位必须软件清零）
 262                  Rec_Buf2[jj] = S2BUF;                   //把串口2缓存SBUF寄存器数据依次存放到数组Rec_Buf2中
 263                  jj++;                                   
 264                if(jj>Buf_Max)                          //接收数大于定义接收数组最大个数时，覆盖接收数组之前值
 265                  {
 266                      jj = 0;
 267                  }           
 268              }
 269              if (S2CON & S2TI)                       //在停止位开始发送时，该位置1
 270              {
 271                  S2CON &= ~S2TI;                       //清除S2CON寄存器对应S2TI位（该位必须软件清零）
 272              }
 273            IE2 |= 0x01;                               // 串口2中断打开 
 274          }
 275          
 276          /**************************************************************************************
 277           * 描  述 : 串口2接收到数据后发送出去
 278           * 入  参 : 无
 279           * 返回值 : 无
 280           **************************************************************************************/
 281          void UART2_Tx_Puts(void)
 282          {
 283            if(Flag)      //有新数据通过串口被接收到
 284            {
 285              IE2 &= 0xFE;                           // 串口2中断关闭 
 286              SendDataByUart2(uart2temp);            //发送字符 
 287              SendDataByUart2(0x0D);                 //发送换行符
 288              SendDataByUart2(0x0A);                 //发送换行符           
 289              IE2 |= 0x01;                           // 串口2中断打开                         
 290              Flag=FALSE;                            //清除接收标识符
 291            }
 292          }
 293          
C51 COMPILER V9.59.0.0   UART                                                              12/19/2022 15:51:54 PAGE 6   

 294          /*********************************END FILE********************************************/ 
 295          uint8 uart3temp;
 296          
 297          /******************************************************************************************串口3
 298           * 描  述 : 串口3初始化函数
 299           * 入  参 : 无
 300           * 返回值 : 无
 301          备注：波特率9600bps   晶振11.0592MHz
 302           **************************************************************************/
 303          void Uart3_Init(void)
 304          { 
 305            S3CON |= 0x10;    //启动串行接收器  
 306            S3CON &= 0x30;    //8位数据,可变波特率,串口3选择定时器2为波特率发生器
 307            AUXR |= 0x04;     //定时器2时钟为Fosc,即1T
 308              
 309              //设置串口管角
 310              P_SW2 &= 0xFD;                         //设置串口引脚，选择RX:P0.0  TX:P0.1
 311          //    P_SW2 |= 0x02;                         //设置串口引脚，选择RX:P5.0  TX:P5.1
 312              
 313              
 314               //选择发送波特率，公式：[TL1，TH1] =65536-(晶振)11059200/(4*波特率)
 315            T2L = 0xE0;     //设定定时初值,波特率9600bps
 316            T2H = 0xFE;     //设定定时初值,波特率9600bps
 317              
 318          //    T2L = 0x40;     //设定定时初值,波特率14400bps
 319          //  T2H = 0xFF;     //设定定时初值,波14400bps
 320            
 321              
 322            AUXR |= 0x10;     //启动定时器2
 323            IE2 |= 0x08;      // 串口3中断打开
 324          }
 325          
 326          /***************************************************************************
 327           * 描  述 : 串口3发送数据函数
 328           * 入  参 : uint8 数据
 329           * 返回值 : 无
 330           **************************************************************************/
 331          void SendDataByUart3(uint8 dat)
 332          {
 333              S3BUF = dat;                 //写数据到UART数据寄存器
 334            while(!(S3CON&S3TI));        //在停止位没有发送时，S3TI为0即一直等待
 335              S3CON&=~S3TI;                //清除S3CON寄存器对应S3TI位（该位必须软件清零）
 336          }
 337          
 338          /***************************************************************************
 339           * 描  述 : 串口3中断服务函数
 340           * 入  参 : 无
 341           * 返回值 : 无
 342           **************************************************************************/
 343          void Uart3() interrupt UART3_VECTOR using 1
 344          {
 345            IE2 &= 0xF7;                // 串口3中断关闭
 346            Flag=TRUE;                       //接收到数据,接收标识符有效
 347            if (S3CON & S3RI)                //串行接收到停止位的中间时刻时，该位置1
 348              {
 349                  S3CON &= ~S3RI;              //清除S3CON寄存器对应S3RI位（该位必须软件清零）
 350                  uart3temp = S3BUF;       
 351              }
 352              if (S3CON & S3TI)                //在停止位开始发送时，该位置1
 353              {
 354                  S3CON &= ~S3TI;              //清除S3CON寄存器对应S3TI位（该位必须软件清零）
 355              }
C51 COMPILER V9.59.0.0   UART                                                              12/19/2022 15:51:54 PAGE 7   

 356            IE2 |= 0x08;                     // 串口3中断打开
 357          }
 358          
 359          /**************************************************************************************
 360           * 描  述 : 串口3接收到数据后发送出去
 361           * 入  参 : 无
 362           * 返回值 : 无
 363           **************************************************************************************/
 364          void UART3_Tx_Puts(void)
 365          {
 366              if(Flag)      //有新数据通过串口被接收到
 367            {
 368              IE2 &= 0xF7;                           //串口3中断关闭
 369              SendDataByUart3(uart3temp);            //发送字符 
 370                  SendDataByUart3(0x0D);                 //发送换行符
 371                  SendDataByUart3(0x0A);                 //发送换行符           
 372              IE2 |= 0x08;                           //串口3中断打开                          
 373              Flag=FALSE;                            //清除接收标识符
 374              }
 375          }
 376          
 377          /*********************************END FILE********************************************/ 
 378          uint8 uart4temp;
 379          
 380          /********************************************************************************************串口4
 381           * 描  述 : 串口4初始化函数
 382           * 入  参 : 无
 383           * 返回值 : 无
 384          备注：波特率9600bps   晶振11.0592MHz
 385           **************************************************************************/
 386          void Uart4_Init(void)
 387          { 
 388            S4CON |= 0x10;    //启动串行接收器  
 389            S4CON &= 0x30;    //8位数据,可变波特率，串口4选择定时器2为波特率发生器
 390            AUXR |= 0x04;     //定时器2时钟为Fosc,即1T
 391              
 392              //设置串口管角
 393              P_SW2 &= 0xFB;                         //设置串口引脚，选择RX:P0.2  TX:P0.3
 394          //    P_SW2 |= 0x04;                         //设置串口引脚，选择RX:P5.2  TX:P5.3
 395              
 396              //选择发送波特率，公式：[TL1，TH1] =65536-(晶振)11059200/(4*波特率)
 397            T2L = 0xE0;     //设定定时初值,波特率9600bps
 398            T2H = 0xFE;     //设定定时初值,波特率9600bps
 399              
 400          //    T2L = 0x40;     //设定定时初值,波特率14400bps
 401          //  T2H = 0xFF;     //设定定时初值,波14400bps
 402              
 403            AUXR |= 0x10;     //启动定时器2
 404            IE2 |= 0x10;      // 串口4中断打开
 405          }
 406          
 407          /***************************************************************************
 408           * 描  述 : 串口4发送数据函数
 409           * 入  参 : uint8 数据
 410           * 返回值 : 无
 411           **************************************************************************/
 412          void SendDataByUart4(uint8 dat)
 413          {
 414              S4BUF = dat;                 //写数据到UART数据寄存器
 415              while(!(S4CON&S4TI));        //在停止位没有发送时，S4TI为0即一直等待
 416              S4CON&=~S4TI;                //清除S4CON寄存器对应S4TI位（该位必须软件清零）
 417          }
C51 COMPILER V9.59.0.0   UART                                                              12/19/2022 15:51:54 PAGE 8   

 418          
 419          /***************************************************************************
 420           * 描  述 : 串口4中断服务函数
 421           * 入  参 : 无
 422           * 返回值 : 无
 423           **************************************************************************/
 424          void Uart4() interrupt UART4_VECTOR using 1
 425          {
 426            IE2 &= 0xEF;                // 串口4中断关闭
 427            Flag=TRUE;                       //接收到数据,接收标识符有效
 428            if (S4CON & S4RI)                //串行接收到停止位的中间时刻时，该位置1
 429            {
 430                S4CON &= ~S4RI;              //清除S4CON寄存器对应S4RI位（该位必须软件清零）
 431                uart4temp = S4BUF;       
 432             }
 433            if (S4CON & S4TI)                //在停止位开始发送时，该位置1
 434             {
 435                S4CON &= ~S4TI;              //清除S4CON寄存器对应S4TI位（该位必须软件清零）
 436             }
 437             IE2 |= 0x10;                     // 串口4中断打开
 438          }
 439          
 440          /**************************************************************************************
 441           * 描  述 : 串口4接收到数据后发送出去
 442           * 入  参 : 无
 443           * 返回值 : 无
 444           **************************************************************************************/
 445          void UART4_Tx_Puts(void)
 446          {
 447            if(Flag)      //有新数据通过串口被接收到
 448            {
 449              IE2 &= 0xEF;                           // 串口4中断关闭
 450              SendDataByUart4(uart4temp);            //发送字符 
 451                  SendDataByUart4(0x0D);                 //发送换行符
 452                  SendDataByUart4(0x0A);                 //发送换行符           
 453              IE2 |= 0x10;                           // 串口4中断打开                   
 454              Flag=FALSE;                            //清除接收标识符
 455            }
 456          }
 457          
 458          /*********************************END FILE********************************************/ 
 459          void UART_Test(void)//串口测试函数
 460          {
 461          //    unsigned char str1[10];
 462          //    unsigned int a=8848;
 463              //液晶初始化
 464              LCD12864_Init();
 465              LCD12864_Clear_Screen(0x00); //清屏
 466          
 467          //    P3M0 = 0x00;P3M1 = 0x00;//按键P54设置为准双向口
 468              Uart1_Init();//串口1初始化函数,选择RX:P3.6  TX:P3.7
 469              EA=1;//打开总中断
 470              
 471              //按键初始化
 472              P5M0 |= (0x01<<4);P5M1 = 0x00;//按键P54设置为准双向口
 473              P4M0 = 0x00;P4M1 = 0x01;//按键P54设置为准双向口
 474          
 475              P54=1;
 476          
 477              while(1)
 478              {
 479                  SendDataByUart1('A');//串口1发送一个字符函数
C51 COMPILER V9.59.0.0   UART                                                              12/19/2022 15:51:54 PAGE 9   

 480                  delay_ms(500);
 481                  SendStringByUart1(" QWE ");//串口1发送字符串数函
 482                  delay_ms(500);
 483                  LCD12864_Display_Chars(1,1,"串口测试程序");//将数组内容显示
 484          //        SendStringByUart1(Rec_Buf1);//串口1发送接收字符串
 485          
 486                  if(P54==0)
 487                  {    
 488                    SendDataByUart1('A');//串口1发送一个字符函数
 489                    SendStringByUart1("Receive the success");//串口1发送字符串数函
 490                    while(!P54);
 491                  }
 492                  
 493                  
 494                  LCD12864_Display_Chars(2,1,"接收：  ");//将数组内容显示
 495                  LCD12864_Display_Chars(2,4,Rec_Buf1);//将数组内容显示
 496                  if(Rec_Buf1[0]=='H'&&Rec_Buf1[1]=='D')//||Rec_Buf1[1]=='E'||Rec_Buf1[2]=='D'||Rec_Buf1[3]=='1'
 497                    P47=1;
 498                  else if(Rec_Buf1[0]=='L')
 499                    P47=0;
 500                  CLR_Buf1();//清除串口1(Rec_Buf1)缓存内容函数
 501          //        delay_ms(500);
 502          //        LCD12864_Clearn(2,1,4);//清除函数
 503              }
 504              
 505          }
 506          

C51 COMPILATION COMPLETE.  1 WARNING(S),  8 ERROR(S)
